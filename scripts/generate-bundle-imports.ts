#!/usr/bin/env tsx
/**
 * Phase 2 - Generate Bundle Imports (Phase 3 Preparation)
 *
 * Generates static import mapping for compile-time bundle inclusion.
 * This enables Edge/serverless deployment by avoiding fs.readFileSync.
 *
 * Output: app/lib/skills/bundleImports.generated.ts
 *
 * Phase 2: Generated but NOT integrated into runtime
 * Phase 3: Will replace fs-based loading in bundleLoader.ts
 *
 * Usage:
 *   npm run generate:bundle-imports
 */

import fs from 'fs';
import path from 'path';

// ========================================
// CONFIGURATION
// ========================================

const BUNDLES_DIR = path.join(process.cwd(), 'app/lib/skills/flow2');
const OUTPUT_FILE = path.join(process.cwd(), 'app/lib/skills/bundleImports.generated.ts');

// ========================================
// MAIN EXECUTION
// ========================================

async function main() {
  console.log('╔═══════════════════════════════════════════════════════════════╗');
  console.log('║  Phase 2 - Generate Bundle Imports (Phase 3 Prep)            ║');
  console.log('╚═══════════════════════════════════════════════════════════════╝\n');

  try {
    console.log('[Step 1/3] Scanning bundle files...');
    const bundles = scanBundleFiles();
    console.log(`✓ Found ${Object.keys(bundles).length} bundle files\n`);

    console.log('[Step 2/3] Generating import statements...');
    const content = generateImportsFile(bundles);
    console.log('✓ Import code generated\n');

    console.log('[Step 3/3] Writing output file...');
    fs.writeFileSync(OUTPUT_FILE, content, 'utf8');
    console.log(`✓ Written to: ${OUTPUT_FILE}\n`);

    console.log('✅ BUNDLE IMPORTS GENERATED');
    console.log('\n⚠️  NOTE: Phase 2 only generates this file.');
    console.log('   Integration into bundleLoader.ts happens in Phase 3.\n');

    process.exit(0);
  } catch (error: any) {
    console.error('\n❌ GENERATION FAILED');
    console.error(`Error: ${error.message}\n`);
    process.exit(1);
  }
}

// ========================================
// BUNDLE SCANNING
// ========================================

interface BundleFiles {
  routing: string;
  topicCatalog: string;
  policyBundle: string;
  promptsBundle: string;
  emailDefault: string;
  emailClarification: string;
  uiCopy?: string;
}

function scanBundleFiles(): BundleFiles {
  const bundles: BundleFiles = {
    routing: path.join(BUNDLES_DIR, 'routing.yaml'),
    topicCatalog: path.join(BUNDLES_DIR, 'topic_catalog.yaml'),
    policyBundle: path.join(BUNDLES_DIR, 'policy_bundle.yaml'),
    promptsBundle: path.join(BUNDLES_DIR, 'prompts_bundle.md'),
    emailDefault: path.join(BUNDLES_DIR, 'templates/email_default.hbs'),
    emailClarification: path.join(BUNDLES_DIR, 'templates/email_clarification.hbs'),
  };

  // Check optional UI copy
  const uiCopyPath = path.join(BUNDLES_DIR, 'templates/ui_copy.md');
  if (fs.existsSync(uiCopyPath)) {
    bundles.uiCopy = uiCopyPath;
  }

  // Validate all required files exist
  for (const [name, filePath] of Object.entries(bundles)) {
    if (!fs.existsSync(filePath)) {
      throw new Error(`Bundle file not found: ${name} at ${filePath}`);
    }
  }

  return bundles;
}

// ========================================
// CODE GENERATION
// ========================================

function generateImportsFile(bundles: BundleFiles): string {
  const lines: string[] = [];

  lines.push('/**');
  lines.push(' * AUTO-GENERATED FILE - DO NOT EDIT');
  lines.push(' * Generated by: scripts/generate-bundle-imports.ts');
  lines.push(' * Generated at: ' + new Date().toISOString());
  lines.push(' *');
  lines.push(' * Static imports for compile-time bundle inclusion.');
  lines.push(' * Enables Edge/serverless deployment without fs.readFileSync.');
  lines.push(' *');
  lines.push(' * Phase 2: Generated but NOT used in runtime');
  lines.push(' * Phase 3: Will replace fs-based loading');
  lines.push(' */');
  lines.push('');

  // Import statements (using ?raw suffix for text files in Next.js/Vite)
  lines.push('// YAML bundles');
  lines.push('import routingYaml from \'./flow2/routing.yaml?raw\';');
  lines.push('import topicCatalogYaml from \'./flow2/topic_catalog.yaml?raw\';');
  lines.push('import policyBundleYaml from \'./flow2/policy_bundle.yaml?raw\';');
  lines.push('');

  lines.push('// Markdown bundles');
  lines.push('import promptsBundleMd from \'./flow2/prompts_bundle.md?raw\';');
  lines.push('');

  lines.push('// Handlebars templates');
  lines.push('import emailDefaultHbs from \'./flow2/templates/email_default.hbs?raw\';');
  lines.push('import emailClarificationHbs from \'./flow2/templates/email_clarification.hbs?raw\';');
  if (bundles.uiCopy) {
    lines.push('import uiCopyMd from \'./flow2/templates/ui_copy.md?raw\';');
  }
  lines.push('');

  // Export interface
  lines.push('export interface StaticBundleImports {');
  lines.push('  routing: string;');
  lines.push('  topicCatalog: string;');
  lines.push('  policyBundle: string;');
  lines.push('  promptsBundle: string;');
  lines.push('  templates: {');
  lines.push('    emailDefault: string;');
  lines.push('    emailClarification: string;');
  lines.push('    uiCopy?: string;');
  lines.push('  };');
  lines.push('}');
  lines.push('');

  // Export bundles object
  lines.push('/**');
  lines.push(' * Static bundle imports');
  lines.push(' * Phase 3: Use this instead of fs.readFileSync for Edge compatibility');
  lines.push(' */');
  lines.push('export const staticBundleImports: StaticBundleImports = {');
  lines.push('  routing: routingYaml,');
  lines.push('  topicCatalog: topicCatalogYaml,');
  lines.push('  policyBundle: policyBundleYaml,');
  lines.push('  promptsBundle: promptsBundleMd,');
  lines.push('  templates: {');
  lines.push('    emailDefault: emailDefaultHbs,');
  lines.push('    emailClarification: emailClarificationHbs,');
  if (bundles.uiCopy) {
    lines.push('    uiCopy: uiCopyMd,');
  }
  lines.push('  },');
  lines.push('};');
  lines.push('');

  // Helper function for Phase 3 integration
  lines.push('/**');
  lines.push(' * Check if static imports are available');
  lines.push(' * Phase 3: Use this to decide between static imports vs fs fallback');
  lines.push(' */');
  lines.push('export function hasStaticImports(): boolean {');
  lines.push('  return typeof staticBundleImports !== \'undefined\';');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

// ========================================
// ENTRY POINT
// ========================================

main().catch((error) => {
  console.error('Unexpected error:', error);
  process.exit(1);
});
